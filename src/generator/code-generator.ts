/**
 * Code Generator
 * Generates TypeScript interfaces and implementation code from entity configurations
 */

import * as fs from 'fs';
import * as path from 'path';
import { EntityConfig, ColumnMapping } from '../entity/entity-config';
import { mapDbTypeToTypeScript } from '../entity/entity-schema';
import { writeEntityYaml } from './yaml-generator';
import { Logger } from '../core/types';
import * as yaml from 'js-yaml';

/**
 * Code generator options
 */
export interface CodeGeneratorOptions {
	/**
	 * Output directory for TypeScript files
	 */
	outputDir?: string;

	/**
	 * Whether to generate entity interfaces
	 */
	generateInterfaces?: boolean;

	/**
	 * Whether to generate repository classes
	 */
	generateRepositories?: boolean;

	/**
	 * Whether to generate barrel files (index.ts)
	 */
	generateBarrels?: boolean;

	/**
	 * Logger instance
	 */
	logger?: Logger;
}

/**
 * Code generator class
 * Generates TypeScript code from entity configurations
 */
export class CodeGenerator {
	private outputDir: string;
	private entitiesDir: string;
	private modelsDir: string;
	private reposDir: string;
	private logger: Logger;
	private options: CodeGeneratorOptions;

	/**
	 * Constructor
	 * @param options Code generator options
	 */
	constructor(options: CodeGeneratorOptions = {}) {
		this.options = {
			outputDir: path.join(process.cwd(), 'src/generated'),
			generateInterfaces: true,
			generateRepositories: true,
			generateBarrels: true,
			...options
		};

		this.outputDir = this.options.outputDir!;
		this.entitiesDir = path.join(this.outputDir, 'entities');
		this.modelsDir = path.join(this.outputDir, 'models');
		this.reposDir = path.join(this.outputDir, 'repositories');

		this.logger = this.options.logger || console;

		// Create output directories
		this.createDirectories();
	}

	/**
	 * Create output directories
	 */
	private createDirectories(): void {
		const dirs = [this.outputDir, this.entitiesDir, this.modelsDir, this.reposDir];

		for (const dir of dirs) {
			if (!fs.existsSync(dir)) {
				fs.mkdirSync(dir, { recursive: true });
			}
		}
	}

	/**
	 * Generate TypeScript interface for an entity
	 * @param entity Entity configuration
	 * @returns TypeScript interface code
	 */
	public generateEntityInterface(entity: EntityConfig): string {
		const { entity: entityName, columns } = entity;

		let code = `/**
 * Generated interface for ${entityName}
 * Auto-generated on ${new Date().toISOString()}
 * DO NOT EDIT THIS FILE DIRECTLY
 */

/**
 * ${entityName} entity interface
 */
export interface ${entityName} {
`;

		// Add properties for each column
		for (const column of columns) {
			const tsType = mapDbTypeToTypeScript(column.type || 'string');
			const optional = column.nullable ? '?' : '';
			const comment = column.comment ? `\n   * ${column.comment}` : '';

			code += `  /**
   * ${column.logical}${comment}
   */
  ${column.logical}${optional}: ${tsType};

`;
		}

		// Add computed properties if defined
		if (entity.computed && entity.computed.length > 0) {
			for (const computed of entity.computed) {
				code += `  /**
   * Computed: ${computed.name}
   */
  ${computed.name}?: any;

`;
			}
		}

		code += `}\n`;

		return code;
	}

	/**
	 * Generate repository class for an entity
	 * @param entity Entity configuration
	 * @returns Repository class code
	 */
	public generateRepositoryClass(entity: EntityConfig): string {
		const { entity: entityName } = entity;

		let code = `/**
 * Generated repository for ${entityName}
 * Auto-generated on ${new Date().toISOString()}
 * DO NOT EDIT THIS FILE DIRECTLY
 */

import { EntityDao } from '../../entity/entity-manager';
import { DatabaseAdapter } from '../../database/core/types';
import { Logger } from '../../core/types';
import { ${entityName} } from '../models/${entityName.toLowerCase()}';
import { entityConfigs } from '../entities';

/**
 * Repository for ${entityName} entity
 */
export class ${entityName}Repository extends EntityDao<${entityName}> {
  /**
   * Constructor
   * @param db Database adapter
   * @param logger Optional logger
   */
  constructor(db: DatabaseAdapter, logger?: Logger) {
    const config = entityConfigs.get('${entityName}');
    if (!config) {
      throw new Error('Entity configuration for ${entityName} not found');
    }
    super(config, db, logger);
  }

  /**
   * Find by ID with proper typing
   * @param id Entity ID
   * @returns Entity or undefined if not found
   */
  async findById(id: number | string): Promise<${entityName} | undefined> {
    return super.findById(id);
  }

  /**
   * Find all entities
   * @param options Query options
   * @returns Array of entities
   */
  async findAll(options?: any): Promise<${entityName}[]> {
    return super.findAll(options);
  }
`;

		// Add relation methods if present
		if (entity.relations && entity.relations.length > 0) {
			for (const relation of entity.relations) {
				const methodName = `get${pascalCase(relation.name)}`;
				const isToMany = relation.type === 'oneToMany' || relation.type === 'manyToMany';
				const returnType = isToMany
					? `Promise<${relation.targetEntity}[]>`
					: `Promise<${relation.targetEntity} | undefined>`;

				code += `
  /**
   * Get related ${relation.targetEntity}${isToMany ? ' entities' : ''}
   * @param id Entity ID
   * @returns Related ${relation.targetEntity}${isToMany ? ' entities' : ''}
   */
  async ${methodName}(id: number | string): ${returnType} {
    return this.findRelated<${relation.targetEntity}>(id, '${relation.name}')${isToMany ? '' : '.then(results => results[0])'};
  }
`;
			}
		}

		// Add custom action methods if present
		if (entity.actions && entity.actions.length > 0) {
			for (const action of entity.actions) {
				code += `
  /**
   * ${action.description || `Execute ${action.name} action`}
   * @param params Action parameters
   * @param context Context for the action
   * @returns Action result
   */
  async ${action.name}(params: any, context?: any): Promise<any> {
    return this.executeAction('${action.name}', params, context);
  }
`;
			}
		}

		code += `}\n`;

		return code;
	}

	/**
	 * Generate entities barrel file (index.ts)
	 * @param entities Entity configurations
	 * @returns Index file content
	 */
	public generateEntitiesBarrel(entities: EntityConfig[]): string {
		let code = `/**
 * Entity configurations barrel file
 * Auto-generated on ${new Date().toISOString()}
 * DO NOT EDIT THIS FILE DIRECTLY
 */

import { EntityConfig } from '../../entity/entity-config';

// Entity configurations
export const entityConfigs = new Map<string, EntityConfig>();

`;

		// Add imports for each entity config
		for (const entity of entities) {
			code += `// ${entity.entity} configuration
entityConfigs.set('${entity.entity}', ${JSON.stringify(entity, null, 2)});

`;
		}

		return code;
	}

	/**
	 * Generate models barrel file (index.ts)
	 * @param entities Entity configurations
	 * @returns Index file content
	 */
	public generateModelsBarrel(entities: EntityConfig[]): string {
		let code = `/**
 * Entity models barrel file
 * Auto-generated on ${new Date().toISOString()}
 * DO NOT EDIT THIS FILE DIRECTLY
 */

`;

		// Add exports for each entity
		for (const entity of entities) {
			code += `export * from './${entity.entity.toLowerCase()}';\n`;
		}

		return code;
	}

	/**
	 * Generate repositories barrel file (index.ts)
	 * @param entities Entity configurations
	 * @returns Index file content
	 */
	public generateRepositoriesBarrel(entities: EntityConfig[]): string {
		let code = `/**
 * Entity repositories barrel file
 * Auto-generated on ${new Date().toISOString()}
 * DO NOT EDIT THIS FILE DIRECTLY
 */

import { DatabaseAdapter } from '../../database/core/types';
import { Logger } from '../../core/types';

`;

		// Add imports for each repository
		for (const entity of entities) {
			code += `import { ${entity.entity}Repository } from './${entity.entity.toLowerCase()}';\n`;
		}

		code += `\n/**
 * Create all repositories
 * @param db Database adapter
 * @param logger Optional logger
 * @returns Map of entity name to repository instance
 */
export function createRepositories(
  db: DatabaseAdapter,
  logger?: Logger
): Map<string, any> {
  const repos = new Map<string, any>();
  
`;

		// Add repository instantiation
		for (const entity of entities) {
			code += `  repos.set('${entity.entity}', new ${entity.entity}Repository(db, logger));\n`;
		}

		code += `
  return repos;
}

/**
 * Typed repository accessor
 * @param name Entity name
 * @param repositories Repository map
 * @returns Typed repository
 */
export function getRepository<T>(
  name: string,
  repositories: Map<string, any>
): T {
  const repo = repositories.get(name);
  if (!repo) {
    throw new Error(\`Repository for \${name} not found\`);
  }
  return repo as T;
}

// Export repository types
`;

		// Add type exports
		for (const entity of entities) {
			code += `export { ${entity.entity}Repository } from './${entity.entity.toLowerCase()}';\n`;
		}

		return code;
	}

	/**
	 * Generate all code for entities
	 * @param entities Entity configurations
	 */
	public generateCode(entities: EntityConfig[]): void {
		this.logger.info(`Generating code for ${entities.length} entities`);

		try {
			// Generate entity interfaces
			if (this.options.generateInterfaces) {
				for (const entity of entities) {
					const interfaceCode = this.generateEntityInterface(entity);
					const filePath = path.join(this.modelsDir, `${entity.entity.toLowerCase()}.ts`);
					fs.writeFileSync(filePath, interfaceCode, 'utf8');
					this.logger.debug(`Generated interface for ${entity.entity}`);
				}
			}

			// Generate repositories
			if (this.options.generateRepositories) {
				for (const entity of entities) {
					const repoCode = this.generateRepositoryClass(entity);
					const filePath = path.join(this.reposDir, `${entity.entity.toLowerCase()}.ts`);
					fs.writeFileSync(filePath, repoCode, 'utf8');
					this.logger.debug(`Generated repository for ${entity.entity}`);
				}
			}

			// Generate barrel files
			if (this.options.generateBarrels) {
				// Entities barrel
				const entitiesBarrel = this.generateEntitiesBarrel(entities);
				fs.writeFileSync(path.join(this.entitiesDir, 'index.ts'), entitiesBarrel, 'utf8');

				// Models barrel
				const modelsBarrel = this.generateModelsBarrel(entities);
				fs.writeFileSync(path.join(this.modelsDir, 'index.ts'), modelsBarrel, 'utf8');

				// Repositories barrel
				const reposBarrel = this.generateRepositoriesBarrel(entities);
				fs.writeFileSync(path.join(this.reposDir, 'index.ts'), reposBarrel, 'utf8');

				this.logger.debug('Generated barrel files');
			}

			this.logger.info('Code generation completed successfully');
		} catch (error: any) {
			this.logger.error(`Code generation failed: ${error}`);
			throw error;
		}
	}

	/**
	 * Generate code from YAML files
	 * @param entitiesDir Directory containing YAML files
	 */
	public generateCodeFromYaml(entitiesDir: string): void {
		try {
			const files = fs.readdirSync(entitiesDir)
				.filter(file => file.endsWith('.yaml') || file.endsWith('.yml'));

			const entities: EntityConfig[] = [];

			for (const file of files) {
				const filePath = path.join(entitiesDir, file);
				const content = fs.readFileSync(filePath, 'utf8');
				const entity = yaml.load(content) as EntityConfig;
				entities.push(entity);
			}

			this.generateCode(entities);
		} catch (error: any) {
			this.logger.error(`Failed to generate code from YAML: ${error}`);
			throw error;
		}
	}

	/**
	 * Scaffold a new entity
	 * @param entityName Entity name in PascalCase
	 * @param tableName Optional table name (defaults to lowercase entity name)
	 * @returns Generated entity configuration
	 */
	public scaffoldEntity(
		entityName: string,
		tableName: string = entityName.toLowerCase()
	): EntityConfig {
		// Create basic entity
		const entity: EntityConfig = {
			entity: entityName,
			table: tableName,
			idField: 'id',
			columns: [
				{
					logical: 'id',
					physical: 'id',
					type: 'integer',
					primaryKey: true,
					autoIncrement: true,
					nullable: false
				},
				{
					logical: 'name',
					physical: 'name',
					type: 'string',
					nullable: false
				},
				{
					logical: 'description',
					physical: 'description',
					type: 'string',
					nullable: true
				},
				{
					logical: 'created_at',
					physical: 'created_at',
					type: 'datetime',
					nullable: false
				},
				{
					logical: 'updated_at',
					physical: 'updated_at',
					type: 'datetime',
					nullable: true
				}
			],
			api: {
				exposed: true,
				basePath: `/${tableName}`,
				operations: {
					getAll: true,
					getById: true,
					create: true,
					update: true,
					delete: true
				},
				permissions: {
					getAll: ['user', 'admin'],
					getById: ['user', 'admin'],
					create: ['admin'],
					update: ['admin'],
					delete: ['admin']
				}
			},
			timestamps: {
				createdAt: 'created_at',
				updatedAt: 'updated_at'
			}
		};

		// Write entity to YAML file
		const yamlDir = path.join(process.cwd(), 'entities');
		if (!fs.existsSync(yamlDir)) {
			fs.mkdirSync(yamlDir, { recursive: true });
		}

		writeEntityYaml(entity, yamlDir);

		// Generate code for the entity
		this.generateCode([entity]);

		this.logger.info(`Entity ${entityName} scaffolded successfully`);

		return entity;
	}
}

/**
 * Helper function to convert a string to PascalCase
 * @param input Input string
 * @returns PascalCase string
 */
function pascalCase(input: string): string {
	return input
		.replace(/(?:^\w|[A-Z]|\b\w)/g, (word, index) =>
			index === 0 ? word.toUpperCase() : word.toUpperCase()
		)
		.replace(/[^a-zA-Z0-9]+/g, '');
}

/**
 * Create a code generator
 * @param options Code generator options
 * @returns Code generator instance
 */
export function createCodeGenerator(options: CodeGeneratorOptions = {}): CodeGenerator {
	return new CodeGenerator(options);
}
// entity-config.test.ts
import {
	EntityConfig,
	ColumnMapping,
	findColumnMapping,
	getPrimaryKeyMapping,
	mapColumnsToPhysical,
	mapColumnToPhysical,
	mapRecordToPhysical,
	mapRecordToLogical,
	getColumnsByType,
	getColumnsByProperty,
	getAllPhysicalColumns,
	getAllLogicalColumns,
	getApiReadableColumns,
	getApiWritableColumns,
	getAutoGeneratedColumns,
	findAction,
	getApiActions,
	createEntityConfig,
	createColumn,
	createPrimaryKey,
	createAutoIncrementPK,
	createTimestampColumns,
	createApiConfig,
	createEntityAction,
	mapToEntity,
	convertToEntityValues
} from "../../src/entity/entity-config";

describe("EntityConfig", () => {
	let testEntityConfig: EntityConfig;

	beforeEach(() => {
		// Create a test entity config for each test
		testEntityConfig = {
			entity: "User",
			table: "users",
			idField: "id",
			columns: [
				{ logical: "id", physical: "user_id", primaryKey: true, autoIncrement: true, type: "integer" },
				{ logical: "name", physical: "user_name", type: "string" },
				{ logical: "email", physical: "user_email", type: "string", unique: true },
				{ logical: "isActive", physical: "is_active", type: "boolean" },
				{ logical: "createdAt", physical: "created_at", type: "datetime", managedTimestamp: "create" },
				{
					logical: "role",
					physical: "user_role",
					type: "string",
					api: {
						readable: true,
						writable: false,
						roles: {
							read: ["admin", "user"],
							write: ["admin"]
						}
					}
				}
			],
			actions: [
				{
					name: "resetPassword",
					implementation: "return { success: true };",
					httpMethod: "POST",
					route: "/reset-password",
					roles: ["admin"]
				},
				{
					name: "getProfile",
					implementation: "return { user: entity };",
					httpMethod: "GET",
					route: "/profile"
				}
			],
			api: {
				exposed: true,
				basePath: "/users",
				operations: {
					getAll: true,
					getById: true,
					create: true,
					update: true,
					delete: true
				},
				permissions: {
					create: ["admin"],
					update: ["admin"],
					delete: ["admin"]
				}
			}
		};
	});

	test("should find column mapping by logical name", () => {
		const column = findColumnMapping(testEntityConfig, "name");

		expect(column).toBeDefined();
		expect(column?.logical).toBe("name");
		expect(column?.physical).toBe("user_name");
	});

	test("should return undefined for non-existent column", () => {
		const column = findColumnMapping(testEntityConfig, "nonExistent");

		expect(column).toBeUndefined();
	});

	test("should get primary key mapping", () => {
		const pkColumn = getPrimaryKeyMapping(testEntityConfig);

		expect(pkColumn).toBeDefined();
		expect((pkColumn as ColumnMapping).logical).toBe("id");
		expect((pkColumn as ColumnMapping).primaryKey).toBe(true);
	});

	test("should throw error if no primary key column", () => {
		const configWithoutPK: EntityConfig = {
			entity: "Test",
			table: "test",
			idField: "nonExistentId",
			columns: [
				{ logical: "name", physical: "name" }
			]
		};

		expect(() => getPrimaryKeyMapping(configWithoutPK)).toThrow();
	});

	test("should map logical columns to physical columns", () => {
		const physicalColumns = mapColumnsToPhysical(
			testEntityConfig,
			["id", "name", "email"]
		);

		expect(physicalColumns).toEqual(["user_id", "user_name", "user_email"]);
	});

	test("should map a logical column to physical column", () => {
		const physical = mapColumnToPhysical(testEntityConfig, "name");

		expect(physical).toBe("user_name");
	});

	test("should return logical name if no mapping exists", () => {
		const physical = mapColumnToPhysical(testEntityConfig, "nonExistent");

		expect(physical).toBe("nonExistent");
	});

	test("should map record with logical names to physical names", () => {
		const logicalRecord = {
			id: 1,
			name: "Test User",
			email: "test@example.com"
		};

		const physicalRecord = mapRecordToPhysical(testEntityConfig, logicalRecord);

		expect(physicalRecord).toEqual({
			user_id: 1,
			user_name: "Test User",
			user_email: "test@example.com"
		});
	});

	test("should map record with physical names to logical names", () => {
		const physicalRecord = {
			user_id: 1,
			user_name: "Test User",
			user_email: "test@example.com"
		};

		const logicalRecord = mapRecordToLogical(testEntityConfig, physicalRecord);

		expect(logicalRecord).toEqual({
			id: 1,
			name: "Test User",
			email: "test@example.com"
		});
	});

	test("should get columns by type", () => {
		const stringColumns = getColumnsByType(testEntityConfig, ["string"]);

		expect(stringColumns.length).toBe(3); // name, email, role
		expect(stringColumns.map(c => c.logical)).toContain("name");
		expect(stringColumns.map(c => c.logical)).toContain("email");
		expect(stringColumns.map(c => c.logical)).toContain("role");
	});

	test("should get columns by property", () => {
		const uniqueColumns = getColumnsByProperty(testEntityConfig, "unique", true);

		expect(uniqueColumns.length).toBe(1);
		expect(uniqueColumns[0].logical).toBe("email");
	});

	test("should get all physical columns", () => {
		const allPhysical = getAllPhysicalColumns(testEntityConfig);

		expect(allPhysical.length).toBe(6);
		expect(allPhysical).toContain("user_id");
		expect(allPhysical).toContain("user_name");
		expect(allPhysical).toContain("user_email");
		expect(allPhysical).toContain("is_active");
		expect(allPhysical).toContain("created_at");
		expect(allPhysical).toContain("user_role");
	});

	test("should get all logical columns", () => {
		const allLogical = getAllLogicalColumns(testEntityConfig);

		expect(allLogical.length).toBe(6);
		expect(allLogical).toContain("id");
		expect(allLogical).toContain("name");
		expect(allLogical).toContain("email");
		expect(allLogical).toContain("isActive");
		expect(allLogical).toContain("createdAt");
		expect(allLogical).toContain("role");
	});

	test("should get API readable columns", () => {
		const readableColumns = getApiReadableColumns(testEntityConfig);

		// All columns should be readable by default
		expect(readableColumns.length).toBe(6);
	});

	test("should get API writable columns", () => {
		const writableColumns = getApiWritableColumns(testEntityConfig);

		// Role column is explicitly not writable
		expect(writableColumns).not.toContain("role");

		// Other columns should be writable by default
		expect(writableColumns).toContain("name");
		expect(writableColumns).toContain("email");
		expect(writableColumns).toContain("isActive");
	});

	test("should get API writable columns for a specific role", () => {
		const userWritable = getApiWritableColumns(testEntityConfig, "user");
		const adminWritable = getApiWritableColumns(testEntityConfig, "admin");

		// User should not be able to write to role
		expect(userWritable).not.toContain("role");

		// Admin should be able to write to role
		expect(adminWritable).toContain("role");
	});

	test("should get auto-generated columns", () => {
		const autoColumns = getAutoGeneratedColumns(testEntityConfig);

		expect(autoColumns.length).toBe(2); // id (autoIncrement) and createdAt (managedTimestamp)
		expect(autoColumns.map(c => c.logical)).toContain("id");
		expect(autoColumns.map(c => c.logical)).toContain("createdAt");
	});

	test("should find action by name", () => {
		const action = findAction(testEntityConfig, "resetPassword");

		expect(action).toBeDefined();
		expect(action?.name).toBe("resetPassword");
		expect(action?.httpMethod).toBe("POST");
	});

	test("should return undefined for non-existent action", () => {
		const action = findAction(testEntityConfig, "nonExistent");

		expect(action).toBeUndefined();
	});

	test("should get API-exposed actions", () => {
		const apiActions = getApiActions(testEntityConfig);

		expect(apiActions.length).toBe(2); // Both actions have httpMethod and route
	});

	test("should get API-exposed actions for a specific role", () => {
		const userActions = getApiActions(testEntityConfig, "user");
		const adminActions = getApiActions(testEntityConfig, "admin");

		// User should only see getProfile
		expect(userActions.length).toBe(1);
		expect(userActions[0].name).toBe("getProfile");

		// Admin should see both
		expect(adminActions.length).toBe(2);
	});

	test("should create entity config", () => {
		const config = createEntityConfig(
			"Post",
			"posts",
			"id",
			[
				createPrimaryKey("id", "post_id"),
				createColumn("title", "post_title", "string"),
				createColumn("content", "post_content", "text")
			]
		);

		expect(config.entity).toBe("Post");
		expect(config.table).toBe("posts");
		expect(config.idField).toBe("id");
		expect(config.columns.length).toBe(3);
	});

	test("should create column", () => {
		const column = createColumn("title", "post_title", "string", { nullable: true });

		expect(column.logical).toBe("title");
		expect(column.physical).toBe("post_title");
		expect(column.type).toBe("string");
		expect(column.nullable).toBe(true);
	});

	test("should create primary key column", () => {
		const pk = createPrimaryKey("id", "post_id", { autoIncrement: true });

		expect(pk.logical).toBe("id");
		expect(pk.physical).toBe("post_id");
		expect(pk.primaryKey).toBe(true);
		expect(pk.autoIncrement).toBe(true);
	});

	test("should create auto-increment primary key column", () => {
		const pk = createAutoIncrementPK();

		expect(pk.logical).toBe("id");
		expect(pk.physical).toBe("id");
		expect(pk.primaryKey).toBe(true);
		expect(pk.autoIncrement).toBe(true);
		expect(pk.type).toBe("integer");
	});

	test("should create timestamp columns", () => {
		const timestampColumns = createTimestampColumns();

		expect(timestampColumns.length).toBe(2); // created_at and updated_at

		const createdAtCol = timestampColumns.find(c => c.logical === "created_at");
		expect(createdAtCol?.managedTimestamp).toBe("create");

		const updatedAtCol = timestampColumns.find(c => c.logical === "updated_at");
		expect(updatedAtCol?.managedTimestamp).toBe("update");
	});

	test("should create timestamp columns with soft delete", () => {
		const timestampColumns = createTimestampColumns("created_at", "updated_at", "deleted_at");

		expect(timestampColumns.length).toBe(3);

		const deletedAtCol = timestampColumns.find(c => c.logical === "deleted_at");
		expect(deletedAtCol?.managedTimestamp).toBe("delete");
	});

	test("should create API config", () => {
		const apiConfig = createApiConfig(true, "/custom-path", {
			operations: {
				getAll: true,
				getById: true,
				create: false,
				update: false,
				delete: false
			}
		});

		expect(apiConfig.exposed).toBe(true);
		expect(apiConfig.basePath).toBe("/custom-path");
		expect(apiConfig.operations?.create).toBe(false);
		expect(apiConfig.operations?.getAll).toBe(true);
	});

	test("should create entity action", () => {
		const action = createEntityAction(
			"activate",
			"return { activated: true };",
			{
				httpMethod: "POST",
				route: "/activate",
				roles: ["admin"]
			}
		);

		expect(action.name).toBe("activate");
		expect(action.implementation).toBe("return { activated: true };");
		expect(action.httpMethod).toBe("POST");
		expect(action.route).toBe("/activate");
		expect(action.roles).toContain("admin");
	});

	test("should map database record to entity", () => {
		const dbRecord = {
			user_id: 1,
			user_name: "Test User",
			user_email: "test@example.com",
			is_active: 1, // Boolean as 1/0
			created_at: "2023-01-01T00:00:00.000Z",
			user_role: "user"
		};

		const entity = mapToEntity(testEntityConfig, dbRecord);

		// Check logical field names
		expect(entity).toHaveProperty("id", 1);
		expect(entity).toHaveProperty("name", "Test User");
		expect(entity).toHaveProperty("email", "test@example.com");

		// Check boolean conversion
		expect(entity).toHaveProperty("isActive", true);

		// Check date conversion (should be Date object)
		expect(entity).toHaveProperty("createdAt");
		if (entity && typeof entity === 'object') {
			const createdAt = (entity as any).createdAt;
			expect(createdAt instanceof Date || typeof createdAt === 'string').toBe(true);
		}
	});

	test("should convert database values to entity values", () => {
		const data = {
			id: 1,
			name: "Test User",
			email: "test@example.com",
			isActive: 1, // Boolean as 1/0
			createdAt: "2023-01-01T00:00:00.000Z"
		};

		const converted = convertToEntityValues(testEntityConfig, data);

		// Check boolean conversion
		expect(converted.isActive).toBe(true);

		// Check date conversion
		expect(converted.createdAt).toBeDefined();
	});

	test("should handle null values in conversion", () => {
		const data = {
			id: 1,
			name: null,
			email: "test@example.com",
			isActive: null
		};

		const converted = convertToEntityValues(testEntityConfig, data);

		expect(converted.name).toBeNull();
		expect(converted.isActive).toBeNull();
	});
});
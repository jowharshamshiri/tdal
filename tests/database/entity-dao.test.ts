// entity-dao.test.ts
import { EntityDao } from '../../src/entity';
import {
	setupTestEnvironment,
	teardownTestEnvironment,
	getTestFramework,
	generateTestData,
	cleanupTestData
} from '../test-setup';
import { faker } from '@faker-js/faker';

// Define interface for User entity based on test-app.yaml
interface User {
	user_id?: number;
	name: string;
	email: string;
	password?: string;
	role: string;
	created_at?: string;
	updated_at?: string;
	last_login?: string;
}

describe("Entity Manager Operations", () => {
	let userManager: EntityDao<User>;
	let framework: any;

	beforeAll(async () => {
		// Initialize test framework with test-app.yaml configuration
		await setupTestEnvironment('./tests/test-app.yaml');
		framework = getTestFramework();

		// Get entity manager from the framework context
		const context = framework.getContext();
		userManager = context.getEntityDao<User>('User');
	});

	afterAll(async () => {
		await teardownTestEnvironment();
	});

	beforeEach(async () => {
		// Clean up any previous test data
		await cleanupTestData();

		// Generate test data with fixed values for predictable test results
		await generateTestData({
			count: 2,  // Generate a reasonable number of records
			withRelations: true,
			fixedValues: {
				User: {
					name: 'Pet Store Owner',
					email: 'owner@dogfoodstore.com',
					role: 'admin',
					password: 'hashedpwd123'
				}
			},
			// Add a second user with custom values
			customGenerators: {
				email: (entity) => entity === 'User' ? 'doggy@example.com' : faker.internet.email()
			}
		});
	});

	test("should find entity by ID", async () => {
		// First find a user to get their ID
		const users = await userManager.find({ email: "owner@dogfoodstore.com" });
		const userId = users[0].user_id;

		const user = await userManager.findById(userId!);

		expect(user).toBeDefined();
		expect(user?.name).toBe("Pet Store Owner");
		expect(user?.email).toBe("owner@dogfoodstore.com");
	});

	test("should return undefined when entity not found by ID", async () => {
		const user = await userManager.findById(999);

		expect(user).toBeUndefined();
	});

	test("should find all entities", async () => {
		const users = await userManager.find({});

		// We should have at least our fixed user plus any faker-generated ones
		expect(users.length).toBeGreaterThan(0);
		// Find our fixed test user
		const testUser = users.find(u => u.email === "owner@dogfoodstore.com");
		expect(testUser).toBeDefined();
		expect(testUser?.name).toBe("Pet Store Owner");
	});

	test("should find entities with query options", async () => {
		// Get a user to ensure we have data
		const allUsers = await userManager.find({});
		expect(allUsers.length).toBeGreaterThan(0);

		// Test with ordering and limit
		const users = await userManager.find(
			{}, // empty filter
			{
				select: ["name", "email"],
				orderBy: { name: "DESC" },
				limit: 1
			}
		);

		expect(users).toHaveLength(1);
		// Since we order by name DESC, the results depend on the data
		// Just check we got valid results with the expected fields
		expect(users[0].name).toBeDefined();
		expect(users[0].email).toBeDefined();
		expect(users[0].password).toBeUndefined(); // Not selected
	});

	test("should find entities by conditions", async () => {
		const users = await userManager.find({ role: "admin" });

		expect(users.length).toBeGreaterThan(0);
		// Find our test admin user
		const adminUser = users.find(u => u.email === "owner@dogfoodstore.com");
		expect(adminUser).toBeDefined();
		expect(adminUser?.name).toBe("Pet Store Owner");
	});

	test("should find one entity by specific conditions", async () => {
		// Use email generated by our custom generator
		const users = await userManager.find({ email: "doggy@example.com" });

		// Should find exactly one user with this email
		expect(users.length).toBe(1);
		expect(users[0].email).toBe("doggy@example.com");
	});

	test("should count entities", async () => {
		const count = await userManager.count({});

		// Should have at least our fixed users plus potentially faker-generated ones
		expect(count).toBeGreaterThan(0);
	});

	test("should count entities with conditions", async () => {
		const count = await userManager.count({ role: "admin" });

		// Should have at least our fixed admin user
		expect(count).toBeGreaterThan(0);
	});

	test("should create an entity", async () => {
		const newUser: Partial<User> = {
			name: "New User",
			email: "new@example.com",
			password: "hashedpwd555",
			role: "user",
		};

		const id = await userManager.create(newUser);

		expect(id).toBeGreaterThan(0);

		// Verify creation with added timestamps
		const user = await userManager.findById(id);
		expect(user).toBeDefined();
		expect(user?.name).toBe("New User");
		expect(user?.created_at).toBeDefined();
	});

	test("should update an entity", async () => {
		// First find a user to get their ID
		const users = await userManager.find({ email: "owner@dogfoodstore.com" });
		const userId = users[0].user_id;

		// Update the user
		const changes = await userManager.update(userId!, {
			name: "Updated Admin"
		});

		expect(changes).toBe(1);

		// Verify update with updated timestamp
		const user = await userManager.findById(userId!);
		expect(user).toBeDefined();
		expect(user?.name).toBe("Updated Admin");
		expect(user?.updated_at).toBeDefined();
	});

	test("should delete an entity", async () => {
		// Create a user specifically for deletion
		const id = await userManager.create({
			name: "User To Delete",
			email: "delete@example.com",
			password: "hashedpwd777",
			role: "user"
		});

		// Delete the user
		const changes = await userManager.delete(id);

		expect(changes).toBe(1);

		// Verify deletion
		const user = await userManager.findById(id);
		expect(user).toBeUndefined();
	});

	test("should check if entity exists", async () => {
		// First find a user to get their ID
		const users = await userManager.find({ email: "owner@dogfoodstore.com" });
		const userId = users[0].user_id!;

		// Check if the user exists
		const exists = await userManager.exists(userId);
		expect(exists).toBe(true);

		// Check a non-existent ID
		const notExists = await userManager.exists(999999);
		expect(notExists).toBe(false);
	});

	test("should perform a transaction", async () => {
		const context = framework.getContext();
		const db = context.getDatabase();

		// Start a transaction
		await db.transaction(async (tx) => {
			// We need to get the entity manager within the transaction
			const txUserManager = context.getEntityDao<User>('User', tx);

			await txUserManager.create({
				name: "Transaction User",
				email: "tx@example.com",
				password: "hashedpwd999",
				role: "user"
			});
		});

		// Verify transaction was committed
		const users = await userManager.find({ email: "tx@example.com" });
		expect(users.length).toBe(1);
		expect(users[0].name).toBe("Transaction User");
	});

	test("should rollback a transaction on error", async () => {
		const context = framework.getContext();
		const db = context.getDatabase();

		try {
			// Start a transaction that will fail
			await db.transaction(async (tx) => {
				// Get the entity manager within the transaction
				const txUserManager = context.getEntityDao<User>('User', tx);

				await txUserManager.create({
					name: "Transaction User",
					email: "tx-rollback@example.com",
					password: "hashedpwd999",
					role: "user"
				});

				// This should cause a unique constraint violation
				await txUserManager.create({
					name: "Duplicate User",
					email: "tx-rollback@example.com", // Same email
					password: "hashedpwd888",
					role: "user"
				});
			});
		} catch (error: any) {
			// Expected error - transaction should be rolled back
		}

		// Verify transaction was rolled back
		const users = await userManager.find({ email: "tx-rollback@example.com" });
		expect(users.length).toBe(0);
	});
});
